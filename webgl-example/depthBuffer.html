<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Depth Buffer</title>

  <link rel="stylesheet" type="text/css" href="./main.css">
  <script src="lib/WebGLRenderer.js"></script>
</head>
<body>
  <main>
    <canvas id="container"></canvas>
  </main>

  <script>
    const vertexShader = `
      attribute vec4 a_position;
      attribute vec4 a_color;

      uniform mat4 u_modelMatrix;
      uniform mat4 u_viewMatrix;
      uniform mat4 u_projectionMatrix;

      varying vec4 vColor;
      varying vec4 vPos;

      void main() {
        gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * a_position;
        vColor = a_color;

        vPos = gl_Position;
      }
    `;
    const fragmentShader = `
      #ifdef GL_ES
      precision mediump float;
      #endif

      varying vec4 vColor;
      varying vec4 vPos;

      void main() {
        float depth = gl_FragCoord.z * 0.5 + 0.5;
        // float depth = vPos.z * 0.5 + 0.5;
        vec3 cubePosition = vPos.xyz / vPos.w * 0.5 + 0.5;
        float x = cubePosition.x;
        float y = cubePosition.y;
        float z = cubePosition.z;

        if (cubePosition.x > 0.5) {
          gl_FragColor = vec4(z, z, z, 1.0);
        }
        else {
          gl_FragColor = vColor;
        }
      }
    `
    const canvas = document.getElementById('container');
    const camera = new WebGLRenderer.Camera({
      type: 'PerspectiveCamera',
      fov: 30,
      aspect: canvas.offsetWidth / canvas.offsetHeight,
      near: 2,
      far: 100,
    });
    camera.setPosition(0, 0, 5);
    camera.lookAt(0, 0, -100);

    // const light = new WebGLRenderer.Light({
    //   // ambientColor: [1, 1, 1],
    //   ambientIntensity: 0.4,
    //   // diffuseColor: [1, 1, 1]
    //   diffuseIntensity: 0.6,
    //   // positon: camera.positon
    // })
    // light.setPosition(10 * RADIUS, 4 * RADIUS, -4 * RADIUS);

    const renderer = new WebGLRenderer.Renderer({
      canvas,
      camera,
      vertexShader,
      fragmentShader,
    });

    const positionArray = new Float32Array([
       0.0,  1.0,   0.0,
      -0.5, -1.0,   0.0,
       0.5, -1.0,   0.0,

       0.0,  1.0,  -2.0,
      -0.5, -1.0,  -2.0,
       0.5, -1.0,  -2.0,

       0.0,  1.0,  -4.0,
      -0.5, -1.0,  -4.0,
       0.5, -1.0,  -4.0,
    ]);
    const colorArray = new Float32Array([
      0.4,  0.4,  1.0,
      0.4,  0.4,  1.0,
      1.0,  0.4,  0.4,

      1.0,  1.0,  0.4,
      1.0,  1.0,  0.4,
      1.0,  0.4,  0.4,

      0.4,  1.0,  0.4,
      0.4,  1.0,  0.4,
      1.0,  0.4,  0.4,
    ]);
    const geometry = {
      attributes: {
        position: new WebGLRenderer.BufferAttribute(positionArray, 3, false),
        color: new WebGLRenderer.BufferAttribute(colorArray, 3, false),
      }
    }
    const { mat4 } = WebGLRenderer;
    geometry.modelMatrix = mat4.translate([], mat4.create(), [0.75, 0, 0]);
    renderer.addGeometry(geometry);
    renderer.render();

    geometry.modelMatrix = mat4.translate([], mat4.create(), [-0.75, 0, 0]);
    renderer.renderGeometry(geometry);

  </script>
</body>
</html>