<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Texture</title>

  <link rel="stylesheet" type="text/css" href="./main.css">
  <script src="lib/WebGLRenderer.js"></script>
</head>
<body>
  <main>
    <canvas id="container"></canvas>
  </main>

  <script>
    const vertexShader = `
      #ifdef GL_ES
      precision mediump float;
      #endif
      attribute vec4 aVertexPosition;
      attribute vec3 aVertexNormal;
      attribute vec2 aTextureCoord;
      // attribute vec3 aDiffuse;
      // attribute vec3 aSpecular;
      // attribute float aSpecularExponent;

      uniform mat4 u_modelMatrix;
      uniform mat4 u_viewMatrix;
      uniform mat4 u_projectionMatrix;
      uniform mat3 u_normalMatrix;

      // light
      uniform vec3 u_lightPosition;

      varying vec3 vNormal;
      varying vec3 vLightDirection;
      varying vec3 vEyeDirection;

      varying vec2 vTextureCoord;

      void main() {
        gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * aVertexPosition;

        vTextureCoord = aTextureCoord;

        // vec4 eyeDirection4 = u_viewMatrix * u_modelMatrix * aVertexPosition;
        vec3 vPosition = (u_viewMatrix * u_modelMatrix * aVertexPosition).xyz;

        vEyeDirection = -vPosition;

        vNormal = (u_normalMatrix * aVertexNormal).xyz;

        // vec3 vLightPosition = (u_viewMatrix * u_modelMatrix * vec4(u_lightPosition, 1.0)).xyz;

        vLightDirection = normalize(u_lightPosition - vPosition);
      }
    `;
    const fragmentShader = `
      #ifdef GL_ES
      precision mediump float;
      #endif

      uniform vec3 u_ambientProduct;
      uniform vec3 u_diffuseProduct;
      uniform vec3 u_specularProduct;
      uniform float u_shininess;

      uniform sampler2D uSampler;

      varying vec3 vNormal;
      varying vec3 vLightDirection;
      varying vec3 vEyeDirection;
      varying vec2 vTextureCoord;

      void main() {
        vec3 vNormal_n = normalize(vNormal);
        vec3 vLightDirection_n = normalize(vLightDirection);
        vec3 vEyeDirection_n = normalize(vEyeDirection);
        vec3 halfwayVector = normalize(vLightDirection_n + vEyeDirection_n);
        vec3 ambient = u_ambientProduct;
        vec3 diffuse = u_diffuseProduct * max(dot(vLightDirection_n, vNormal_n), 0.0);
        vec3 specular = u_specularProduct * pow(max(dot(halfwayVector, vNormal_n), 0.0), u_shininess);
        if (dot(vLightDirection_n, vNormal_n) < 0.0) {
          specular = vec3(0.0, 0.0, 0.0);
        }

        vec3 color = ambient + diffuse + specular;
        vec4 texture = texture2D(uSampler, vTextureCoord);

        gl_FragColor = vec4(color * texture.rgb, texture.a);
      }
    `;
    const canvas = document.getElementById('container');
    const camera = new WebGLRenderer.Camera({
      type: 'PerspectiveCamera',
      fov: 45,
      aspect: canvas.offsetWidth / canvas.offsetHeight,
      near: 0.01,
      far: 100,
    });
    camera.setPosition(-1.5, 0.5, -2);
    camera.lookAt(0, 0, 0);

    const light = new WebGLRenderer.Light({
      // ambientColor: [1, 1, 1],
      ambientIntensity: 0.2,
      // diffuseColor: [1, 1, 1]
      diffuseIntensity: 0.6,
      specularIntensity: 0.3,
      shininess: 100,
      position: [2, 6, 10],
    });

    const renderer = new WebGLRenderer.Renderer({
      canvas,
      camera,
      light,
      vertexShader,
      fragmentShader,
    });

    const gl = renderer.gl;
    const { OBJ } = WebGLRenderer;
    const attrs = {
      aVertexPosition: OBJ.Layout.POSITION.key,
      aVertexNormal: OBJ.Layout.NORMAL.key,
      aTextureCoord: OBJ.Layout.UV.key,
      // aDiffuse: OBJ.Layout.DIFFUSE.key,
      // aSpecular: OBJ.Layout.SPECULAR.key,
      // aSpecularExponent: OBJ.Layout.SPECULAR_EXPONENT.key
    };
    const layout = new OBJ.Layout(
      OBJ.Layout.POSITION,
      OBJ.Layout.NORMAL,
      OBJ.Layout.UV,
      // OBJ.Layout.DIFFUSE,
      // OBJ.Layout.SPECULAR,
      // OBJ.Layout.SPECULAR_EXPONENT
    );

    function fetchImage(url) {
      return new Promise(resolve => {
        fetch(url)
          .then(response => response.blob())
          .then(data => {
            const image = new Image();
            image.onload = () => {
              resolve(image);
            }
            image.src = URL.createObjectURL(data);
          })
          .catch(() => {
            console.error(`Unable to download texture image: ${url}`);
          });
      });
    }

    (function() {
      Promise.all([
        OBJ.downloadModels([
          {
            obj: "./data/spot/spot_triangulated_good.obj",
          }
        ]),
        fetchImage('./data/spot/spot_texture.png')
      ]).then(([models, textureImage]) => {
        renderer.render();

        const programUniforms = renderer.program.uniforms;
        bindTexture(textureImage, programUniforms.uSampler, 0);
        // model matrix 单位向量 特殊处理
        const normalMatrix = WebGLRenderer.mat3.create();
        const mvMatrix = renderer.camera.viewMatrix;
        WebGLRenderer.mat3.fromMat4(normalMatrix, WebGLRenderer.mat4.invert([], mvMatrix));
        WebGLRenderer.mat3.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix3fv(programUniforms.u_normalMatrix, false, normalMatrix)

        models.spot_triangulated_good.needUpdate = true;
        renderer.renderOBJ(models.spot_triangulated_good, layout, attrs);
      });
    })();

    function bindTexture(image, samplerLocation, index) {
      const texture = gl.createTexture();
      applyTexture(image, texture, index);
      gl.activeTexture(gl[`TEXTURE${index}`]);
      // Bind the texture object to the target
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(samplerLocation, index);
    }

    function applyTexture(image, texture, index) {
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.texImage2D(gl.TEXTURE_2D, index, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }

  </script>
</body>
</html>